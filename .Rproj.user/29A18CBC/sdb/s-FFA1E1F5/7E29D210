{
    "contents" : "#-----------\n# SQL Translation\n#------------\n\n\n#--------------------\n# genSQL Function\n#     The genSQL function currently works for the following model types\n#              * Any lm model with interactions\n#              * Any binomial logistic regression model with interactions\n#              * Any rpart model\n# Input: model - an object of type lm(), glm(), or rpart()\n#        digits - the number of digits to round to, defaults to machine's floating point precision\n#        outcome.name - the name for the decision tree prediction, defaults to NULL\n# Output: An ANSI SQL calculation for the model\n# Calls: lm2sql(), glm2sql(), tree2sql()\n#------------------\n\ngenSQL <- function(model, digits = .Machine$sizeof.longdouble, outcome.name = NULL) {\n  model.class <- class(model)[1]\n  # Error handling\n  if (any(model.class == c(\"glm\", \"rpart\", \"lm\")) == FALSE) {\n    warning(model.class, \" is not a supported model type\")\n    stop()\n  }\n  \n  # Model function selection\n    if (model.class == \"lm\") {\n        sql.statement <- lm2sql(lm.model = model, digits)\n    } else if (model.class == \"glm\") {\n        sql.statement <- glm2sql(glm.model = model, digits)\n    } else if (model.class == \"rpart\") {\n        sql.statement <- tree2sql(dtree=model, outcome.name)\n    }\n  \n  return(sql.statement)\n}\n\n\n#-----------------\n# lm2sql\n# Input: lm.model - a model of class \"lm\"\n#        digits - the number of digits to round to\n# Output: an SQL description of the model\n#----------------\n\nlm2sql <- function(lm.model, digits) {\n  # Get the coefficients\n  coeff <- summary(lm.model)$coefficients[, \"Estimate\"]\n  coeff <- round(coeff, digits)\n  # Store the variable names\n  var.names <- rownames(summary(lm.model)$coefficients)\n  # Concatenate the coefficients and variable names\n  sql.var <- paste(coeff[-1], \"*\" ,var.names[-1], \"+\", collapse = \" \")\n  # Concatentate the SQL syntax and add the intercept\n  sql.statement <- paste(\"SELECT\", sql.var, coeff[1])\n  # Apply any interaction correction\n  sql.statement <- interaction.correction(sql.statement)\n  \n  return(sql.statement)\n}\n\n#-------------\n# glm2sql\n# Input: glm.model - a model of class \"glm\"\n#        digits - the number of digits to round to\n# Output: an SQL description of the model\n# Notes: only supports binomial logistic regression\n#----------------\n\nglm2sql <- function(glm.model, digits) {\n  # Error checking\n  if (glm.model$family$family != \"binomial\") {\n    warning(\"Only binomial logistic regression supported\")\n    stop()\n  }\n  # Get the coefficients\n  coeff <- summary(glm.model)$coefficients[, \"Estimate\"]\n  coeff <- round(coeff, digits)\n  # Store the variable names\n  var.names <- rownames(summary(glm.model)$coefficients)\n  # Concatenate the coefficients and variable names\n  sql.var <- paste(coeff[-1], \"*\" ,var.names[-1], \"+\", collapse = \" \")\n  # Concatenate the SQL syntax and add the intercept\n  sql.statement <- paste(\"SELECT 1 / (1 + exp(\", sql.var, coeff[1], \"))\")\n  # Apply any interaction correction\n  sql.statement <- interaction.correction(sql.statement)\n  \n  return(sql.statement)\n}\n\n#----------\n# interaction.check\n#   Checks to see if any of the specified model terms are interactions\n# Input: sql.statement -\n# Output: a sql statement with the interactions correctly specified\n#------------\ninteraction.correction <- function(sql.statement) {\n corrected.statement <- gsub(pattern=\":\", replacement=\"*\", x=sql.statement) \n return(corrected.statement)\n}\n\n#---------------------------------\n# Tree Parse Function\n# Input: dtree - a decision tree from rpart()\n# Output: the parsed rule set\n#-----------------------------------\n\ntree.parse <- function(dtree) {\n  # Grab the rule stack\n  rule.stack <- capture.output(dtree)\n  # Remove the data to the right of the rule\n  match.right <- regexpr(pattern=\"[[:digit:]]+[[:space:]]{2}[[:digit:]].*\", text=rule.stack)\n  sub.result <- unlist(regmatches(x = rule.stack, m=match.right, invert = TRUE))\n  # Remove the rule number and spaces to the left of the rule\n  match.left <- regexpr(pattern=\"[[:space:]]*[[:digit:]]+)[[:space:]]\", text = sub.result)\n  final.result <- unlist(regmatches(x = sub.result, m=match.left, invert=TRUE))\n  final.result <- final.result[final.result != \"\"][-1:-4]\n  \n  return(final.result)\n}\n\n#--------------\n# Node Prediction Function\n# Input: dtree - a decision tree from rpart()\n# Output: a vector of the probabilities/predictions for each node\n#-------------\n\nnode.pred <- function(dtree) {\n  pred.df <- NA\n  \n  if (dtree$method == \"anova\") { pred <- dtree$frame$yval\n    } else if (dtree$method == \"class\") { pred <- dtree$frame$yval2[, 4] }\n  \n  leaf <- ifelse(dtree$frame$var == \"<leaf>\", yes=1, no = 0)\n  \n  pred.df <- data.frame(\"node\" = rownames(dtree$frame), \"pred\" = pred, \"leaf\" = leaf)\n  \n  return(pred.df)\n}\n\n#--------------------\n# Tree Stack Function\n# Input: dtree - a decision tree from rpart()\n# Output: a rule stack data frame\n# Required: node.pred(), tree.parse()\n#------------------\n\ntree.stack <- function(dtree) {\n  df <- node.pred(dtree)\n  node.rule <- c(\"root\", tree.parse(dtree))\n  df <- data.frame(df, \"rule\" = node.rule)\n  \n  return(df)\n}\n\n#------------------\n# Tree to SQL Translation Function\n# Input: dtree - a decision tree from rpart()\n#        outcome.name - the name for the predicted value\n# Output: An ANSI SQL description of the model\n# Required: tree.stack(), node.pred(), tree.parse()\n#----------------\n\ntree2sql <- function(dtree, outcome.name) {\n  \n  # Initialize\n  stack <- tree.stack(dtree)\n  sql.statement <- NULL\n  curr.state <- 0\n  branch.depth <- 0\n  \n  # Loop through each rule in the stack\n  for (i in 2:dim(stack)[1]) {\n    # Setup\n    #-----------\n    # Current and Next State\n    if (i == 2) { curr.state <- 0\n      } else { curr.state <- stack[i-1, \"leaf\"]}\n    next.state <- stack[i, \"leaf\"]\n    # Current Rule\n    rule.i <- stack[i, \"rule\"]\n    # Tab number\n    tabs <- paste(rep(\"\\t\", times=branch.depth), collapse='')\n    \n    # Logic: Translates stack -> tree\n    #-------------\n    # Node -> Node\n    if (curr.state == 0 & next.state == 0) {\n      # Write statement\n      statement.i <- paste(\"\\n\", tabs, \"CASE WHEN\", rule.i, \"THEN\")\n      sql.statement <- paste(sql.statement, statement.i)\n      # Increment branch depth\n      branch.depth <- branch.depth + 1\n      next()\n    }\n    # Node -> Leaf Transition\n    if (curr.state == 0 & next.state == 1) {\n      # Write statement\n      pred.i <- stack[i, \"pred\"]\n      statement.i <- paste(\"\\n\", tabs, \"CASE WHEN\", rule.i, \"THEN\", pred.i)\n      sql.statement <- paste(sql.statement, statement.i)\n      # Increment branch depth\n      branch.depth <- branch.depth + 1\n      next()\n    }           \n    # Leaf -> Node Transition\n    if (curr.state == 1 & next.state == 0) {\n      # Write statement\n      statement.i <- paste(\"\\n\", tabs, \"WHEN\", rule.i, \"THEN\")\n      sql.statement <- paste(sql.statement, statement.i)\n      next()\n    }\n    # Leaf -> Leaf Transition\n    if (curr.state == 1 & next.state == 1) {\n      # Write statement\n      pred.i <- stack[i, \"pred\"]\n      statement.i <- paste(\"\\n\", tabs, \"WHEN\", rule.i, \"THEN\", pred.i)\n      sql.statement <- paste(sql.statement, statement.i)\n      # Close 1 open CASE statement\n      sql.statement <- paste(sql.statement, \"\\n\", tabs, \"END\")\n      # Decrement the branch.depth\n      branch.depth <- branch.depth - 1\n      next()\n    }\n  }\n  # END any hanging CASE clauses\n  termination <- paste(rep(\"\\nEND\", times = branch.depth), collapse='')\n  # Throw on the outcomes name\n  sql.statement <- paste(\"SELECT\", sql.statement, termination, \"AS\", outcome.name)\n  return(sql.statement)\n}\n\n",
    "created" : 1334862561030.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "hash" : "434292749",
    "id" : "7E29D210",
    "lastKnownWriteTime" : 1330986822,
    "path" : "//QL1WSSV3/USERS/JCapehart/Desktop/Tools Experiment/genSQL/genSQL.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}